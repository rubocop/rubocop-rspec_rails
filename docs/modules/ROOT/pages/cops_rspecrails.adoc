////
  Do NOT edit this file by hand directly, as it is automatically generated.

  Please make any necessary changes to the cop documentation within the source files themselves.
////

= RSpecRails

[#rspecrailsavoidsetuphook]
== RSpecRails/AvoidSetupHook

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| Always
| 2.4
| -
|===

Checks that tests use RSpec `before` hook over Rails `setup` method.

[#examples-rspecrailsavoidsetuphook]
=== Examples

[source,ruby]
----
# bad
setup do
  allow(foo).to receive(:bar)
end

# good
before do
  allow(foo).to receive(:bar)
end
----

[#references-rspecrailsavoidsetuphook]
=== References

* https://www.rubydoc.info/gems/rubocop-rspec_rails/RuboCop/Cop/RSpecRails/AvoidSetupHook

[#rspecrailshavehttpstatus]
== RSpecRails/HaveHttpStatus

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| Always (Unsafe)
| 2.12
| 2.27
|===

Checks that tests use `have_http_status` instead of equality matchers.

[#safety-rspecrailshavehttpstatus]
=== Safety

The autocorrection is marked as unsafe because
`response.status` response is not always an HTTP response.

[#examples-rspecrailshavehttpstatus]
=== Examples

[#responsemethods_-__response__-_last_response__-_default_-rspecrailshavehttpstatus]
==== ResponseMethods: ['response', 'last_response'] (default)

[source,ruby]
----
# bad
expect(response.status).to be(200)
expect(last_response.code).to eq("200")

# good
expect(response).to have_http_status(200)
expect(last_response).to have_http_status(200)
----

[#responsemethods_-__foo_response__-rspecrailshavehttpstatus]
==== ResponseMethods: ['foo_response']

[source,ruby]
----
# bad
expect(foo_response.status).to be(200)

# good
expect(foo_response).to have_http_status(200)

# also good
expect(response).to have_http_status(200)
expect(last_response).to have_http_status(200)
----

[#configurable-attributes-rspecrailshavehttpstatus]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| ResponseMethods
| `response`, `last_response`
| Array
|===

[#references-rspecrailshavehttpstatus]
=== References

* https://www.rubydoc.info/gems/rubocop-rspec_rails/RuboCop/Cop/RSpecRails/HaveHttpStatus

[#rspecrailshttpstatus]
== RSpecRails/HttpStatus

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 1.23
| 2.20
|===

Enforces use of symbolic or numeric value to describe HTTP status.

This cop inspects only `have_http_status` calls.
So, this cop does not check if a method starting with `be_*` is used
when setting for `EnforcedStyle: symbolic` or
`EnforcedStyle: numeric`.
This cop is also capable of detecting unknown HTTP status codes.

[#examples-rspecrailshttpstatus]
=== Examples

[#_enforcedstyle_-symbolic_-_default_-rspecrailshttpstatus]
==== `EnforcedStyle: symbolic` (default)

[source,ruby]
----
# bad
it { is_expected.to have_http_status 200 }
it { is_expected.to have_http_status 404 }
it { is_expected.to have_http_status "403" }

# good
it { is_expected.to have_http_status :ok }
it { is_expected.to have_http_status :not_found }
it { is_expected.to have_http_status :forbidden }
it { is_expected.to have_http_status :success }
it { is_expected.to have_http_status :error }
----

[#_enforcedstyle_-numeric_-rspecrailshttpstatus]
==== `EnforcedStyle: numeric`

[source,ruby]
----
# bad
it { is_expected.to have_http_status :ok }
it { is_expected.to have_http_status :not_found }
it { is_expected.to have_http_status "forbidden" }

# good
it { is_expected.to have_http_status 200 }
it { is_expected.to have_http_status 404 }
it { is_expected.to have_http_status 403 }
it { is_expected.to have_http_status :success }
it { is_expected.to have_http_status :error }
----

[#_enforcedstyle_-be_status_-rspecrailshttpstatus]
==== `EnforcedStyle: be_status`

[source,ruby]
----
# bad
it { is_expected.to have_http_status :ok }
it { is_expected.to have_http_status :not_found }
it { is_expected.to have_http_status "forbidden" }
it { is_expected.to have_http_status 200 }
it { is_expected.to have_http_status 404 }
it { is_expected.to have_http_status "403" }

# good
it { is_expected.to be_ok }
it { is_expected.to be_not_found }
it { is_expected.to have_http_status :success }
it { is_expected.to have_http_status :error }
----

[source,ruby]
----
# bad
it { is_expected.to have_http_status :oki_doki }

# good
it { is_expected.to have_http_status :ok }
----

[#configurable-attributes-rspecrailshttpstatus]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `symbolic`
| `numeric`, `symbolic`, `be_status`
|===

[#references-rspecrailshttpstatus]
=== References

* https://www.rubydoc.info/gems/rubocop-rspec_rails/RuboCop/Cop/RSpecRails/HttpStatus

[#rspecrailsinferredspectype]
== RSpecRails/InferredSpecType

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| No
| Always (Unsafe)
| 2.14
| -
|===

Identifies redundant spec type.

After setting up rspec-rails, you will have enabled
`config.infer_spec_type_from_file_location!` by default in
spec/rails_helper.rb. This cop works in conjunction with this config.
If you disable this config, disable this cop as well.

[#safety-rspecrailsinferredspectype]
=== Safety

This cop is marked as unsafe because
`config.infer_spec_type_from_file_location!` may not be enabled.

[#examples-rspecrailsinferredspectype]
=== Examples

[source,ruby]
----
# bad
# spec/models/user_spec.rb
RSpec.describe User, type: :model do
end

# good
# spec/models/user_spec.rb
RSpec.describe User do
end

# good
# spec/models/user_spec.rb
RSpec.describe User, type: :common do
end
----

[#_inferences_-configuration-rspecrailsinferredspectype]
==== `Inferences` configuration

[source,ruby]
----
# .rubocop.yml
# RSpecRails/InferredSpecType:
#   Inferences:
#     services: service

# bad
# spec/services/user_spec.rb
RSpec.describe User, type: :service do
end

# good
# spec/services/user_spec.rb
RSpec.describe User do
end

# good
# spec/services/user_spec.rb
RSpec.describe User, type: :common do
end
----

[#configurable-attributes-rspecrailsinferredspectype]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| Inferences
| `{"channels" => "channel", "controllers" => "controller", "features" => "feature", "generator" => "generator", "helpers" => "helper", "jobs" => "job", "mailboxes" => "mailbox", "mailers" => "mailer", "models" => "model", "requests" => "request", "integration" => "request", "api" => "request", "routing" => "routing", "system" => "system", "views" => "view"}`
| 
|===

[#references-rspecrailsinferredspectype]
=== References

* https://www.rubydoc.info/gems/rubocop-rspec_rails/RuboCop/Cop/RSpecRails/InferredSpecType

[#rspecrailsminitestassertions]
== RSpecRails/MinitestAssertions

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| Always
| 2.17
| -
|===

Check if using Minitest-like matchers.

Check the use of minitest-like matchers
starting with `assert_` or `refute_`.

[#examples-rspecrailsminitestassertions]
=== Examples

[source,ruby]
----
# bad
assert_equal(a, b)
assert_equal a, b, "must be equal"
assert_not_includes a, b
refute_equal(a, b)
assert_nil a
refute_empty(b)
assert_true(a)
assert_false(a)

# good
expect(b).to eq(a)
expect(b).to(eq(a), "must be equal")
expect(a).not_to include(b)
expect(b).not_to eq(a)
expect(a).to eq(nil)
expect(a).not_to be_empty
expect(a).to be(true)
expect(a).to be(false)
----

[#references-rspecrailsminitestassertions]
=== References

* https://www.rubydoc.info/gems/rubocop-rspec_rails/RuboCop/Cop/RSpecRails/MinitestAssertions

[#rspecrailsnegationbevalid]
== RSpecRails/NegationBeValid

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| No
| Command-line only (Unsafe)
| 2.23
| 2.29
|===

Enforces use of `be_invalid` or `not_to` for negated be_valid.

[#safety-rspecrailsnegationbevalid]
=== Safety

This cop is unsafe because it cannot guarantee that
the test target is an instance of `ActiveModel::Validations``.

[#examples-rspecrailsnegationbevalid]
=== Examples

[#enforcedstyle_-not_to-_default_-rspecrailsnegationbevalid]
==== EnforcedStyle: not_to (default)

[source,ruby]
----
# bad
expect(foo).to be_invalid

# good
expect(foo).not_to be_valid

# good (with method chain)
expect(foo).to be_invalid.and be_odd
----

[#enforcedstyle_-be_invalid-rspecrailsnegationbevalid]
==== EnforcedStyle: be_invalid

[source,ruby]
----
# bad
expect(foo).not_to be_valid

# good
expect(foo).to be_invalid

# good (with method chain)
expect(foo).to be_invalid.or be_even
----

[#configurable-attributes-rspecrailsnegationbevalid]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `not_to`
| `not_to`, `be_invalid`
|===

[#references-rspecrailsnegationbevalid]
=== References

* https://www.rubydoc.info/gems/rubocop-rspec_rails/RuboCop/Cop/RSpecRails/NegationBeValid

[#rspecrailstravelaround]
== RSpecRails/TravelAround

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| No
| Always (Unsafe)
| 2.19
| -
|===

Prefer to travel in `before` rather than `around`.

[#safety-rspecrailstravelaround]
=== Safety

This cop is unsafe because the automatic `travel_back` is only run
on test cases that are considered as Rails related.

And also, this cop's autocorrection is unsafe because the order of
execution will change if other steps exist before traveling in
`around`.

[#examples-rspecrailstravelaround]
=== Examples

[source,ruby]
----
# bad
around do |example|
  freeze_time do
    example.run
  end
end

# bad
around do |example|
  freeze_time(&example)
end

# good
before { freeze_time }
----

[#references-rspecrailstravelaround]
=== References

* https://www.rubydoc.info/gems/rubocop-rspec_rails/RuboCop/Cop/RSpecRails/TravelAround
